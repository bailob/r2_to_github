name: "Storage to GitHub"
description: "Transfer files from Cloudflare R2 and/or Backblaze B2 to GitHub repositories based on size or quantity strategy."
author: "fscarmen2"
inputs:
  config_path:
    description: "Path to the configuration YAML file."
    required: true
    default: "./config.yml"
outputs:
  result:
    description: "Summary of the action's execution."

runs:
  using: composite
  steps:
    - name: Runing
      run: |
        # 添加文件名验证函数
        validate_filename() {
          local filename="$1"
          # 检查文件名是否为空
          if [ -z "$filename" ]; then
            return 1
          fi
          # 检查文件名是否包含非法字符
          if [[ "$filename" =~ [^[:alnum:][:space:]._-] ]]; then
            echo "警告：文件名 '$filename' 包含非法字符"
            return 1
          fi
          return 0
        }

        # 脚本开始，输出起始日志
        echo "开始 Storage ---> GitHub 脚本"

        # 读取并格式化配置文件，确保冒号后有空格，并移除特殊字符
        CONFIG=$(sed 's/[<>]//g; s/:/: /g; s/:[[:space:]]\+/: /g' "${{ inputs.config_path }}")

        # 检查并读取 R2 存储配置（如果存在）
        if yq -e '.r2_accounts' <<< "$CONFIG" >/dev/null 2>&1; then
          # 解析 R2 账户相关信息
          mapfile -t R2_ACCOUNT_NAME < <(yq '.r2_accounts[].name' <<< "$CONFIG")
          mapfile -t R2_ACCOUNT_ID < <(yq '.r2_accounts[].account_id' <<< "$CONFIG")
          mapfile -t R2_ACCESS_KEY_ID < <(yq '.r2_accounts[].access_key_id' <<< "$CONFIG")
          mapfile -t R2_SECRET_ACCESS_KEY < <(yq '.r2_accounts[].secret_access_key' <<< "$CONFIG")
          mapfile -t R2_BUCKET < <(yq '.r2_accounts[].bucket' <<< "$CONFIG")
          mapfile -t R2_DIR < <(yq '.r2_accounts[].dir' <<< "$CONFIG")
          
          # 构建 R2 存储的端点 URL
          for o in "${R2_ACCOUNT_ID[@]}"; do
            R2_ENDPOINT_URL+=(https://${o}.r2.cloudflarestorage.com)
          done
        fi

        # 检查并读取 B2 存储配置（如果存在）
        if yq -e '.b2_accounts' <<< "$CONFIG" >/dev/null 2>&1; then
          # 解析 B2 账户相关信息
          mapfile -t B2_ACCOUNT_NAME < <(yq '.b2_accounts[].name' <<< "$CONFIG")
          mapfile -t B2_ENDPOINT < <(yq '.b2_accounts[].endpoint' <<< "$CONFIG")
          mapfile -t B2_KEY_ID < <(yq '.b2_accounts[].key_id' <<< "$CONFIG")
          mapfile -t B2_APPLICATION_KEY < <(yq '.b2_accounts[].application_key' <<< "$CONFIG")
          mapfile -t B2_BUCKET < <(yq '.b2_accounts[].bucket' <<< "$CONFIG")
          mapfile -t B2_DIR < <(yq '.b2_accounts[].dir' <<< "$CONFIG")
          
          # 构建 B2 存储的端点 URL
          for p in "${B2_ENDPOINT[@]}"; do
            B2_ENDPOINT_URL+=(https://${p})
          done
        fi

        # 从配置文件中读取 GitHub 相关参数
        GITHUB_PAT=$(yq '.github_pat' <<< "$CONFIG")
        GITHUB_REPO_PREFIX=$(yq '.github_repo_prefix' <<< "$CONFIG")
        mapfile -t GITHUB_REPO_LIST < <(yq '.gitlab_pats | keys | .[]' <<< "$CONFIG" | sed "s/^/${GITHUB_REPO_PREFIX}&/g")
        GITHUB_USERNAME=$(curl --silent --header "Authorization: Bearer $GITHUB_PAT" https://api.github.com/user | jq -r '.login')

        # 获取迁移策略和是否删除原文件的配置
        STRATEGY=$(yq '.strategy' <<< "$CONFIG")
        DELETE=$(yq '.delete' <<< "$CONFIG")

        # 检查策略是否直接指定了仓库
        for j in "${GITHUB_REPO_LIST[@]}"; do
          grep -qw "${STRATEGY}" <<< "$j" && REPO_NAME="${STRATEGY}" && break
        done

        # 根据策略选择目标仓库
        if [ -n "$REPO_NAME" ]; then
          STRATEGY_RESULT="策略: 指定存放到 ${REPO_NAME}"
        elif [ "${STRATEGY,,}" = 'quantity' ]; then
          MIN_INDEX=0
          MIN_FILE_QUANTITY=$(curl --silent \
            --header "Authorization: token ${GITHUB_PAT}" \
            --header "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${GITHUB_USERNAME}/${GITHUB_REPO_LIST[0]}/contents/${R2_DIR}" | grep -c '"name"')

          for ((i=1; i<${#GITHUB_REPO_LIST[@]}; i++)); do
            REPO_FILE_QUANTITY=$(curl --silent \
              --header "Authorization: token ${GITHUB_PAT}" \
              --header "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${GITHUB_USERNAME}/${GITHUB_REPO_LIST[i]}/contents/${R2_DIR}" | grep -c '"name"')
            if [[ "$MIN_FILE_QUANTITY" -gt "$REPO_FILE_QUANTITY" ]]; then
              MIN_FILE_QUANTITY="$REPO_FILE_QUANTITY"
              MIN_INDEX="$i"
            fi
          done
          REPO_NAME=${GITHUB_REPO_LIST[MIN_INDEX]}
          STRATEGY_RESULT="策略: 存放到文件数量最少的 ${REPO_NAME}"
        else
          grep -qwE 'size|quantity' <<< "${STRATEGY,,}" || echo "Strategy 现在 [${STRATEGY}] 不可用， 将采用默认策略 size，可选项是 [size|quantity|$(sed 's/ /|/g' <<< "${GITHUB_REPO_LIST[*]}")]"
          MIN_INDEX=0
          MIN_REPO_SIZE=$(curl --silent \
            --header "Authorization: token ${GITHUB_PAT}" \
            --header "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${GITHUB_USERNAME}/${GITHUB_REPO_LIST[0]}/contents/${R2_DIR}" | jq '[.[] | .size] | add // 0')

          for ((i=1; i<${#GITHUB_REPO_LIST[@]}; i++)); do
            REPO_SIZE=$(curl --silent \
              --header "Authorization: token ${GITHUB_PAT}" \
              --header "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${GITHUB_USERNAME}/${GITHUB_REPO_LIST[i]}/contents/${R2_DIR}" | jq '[.[] | .size] | add // 0')
            if [[ "$MIN_REPO_SIZE" -gt "$REPO_SIZE" ]]; then
              MIN_REPO_SIZE="$REPO_SIZE"
              MIN_INDEX="$i"
            fi
          done
          REPO_NAME=${GITHUB_REPO_LIST[MIN_INDEX]}
          STRATEGY_RESULT="策略: 存放到仓库容量最少的 ${REPO_NAME}"
        fi

        # Git 配置
        git config --global user.name 'github-actions'
        git config --global user.email 'github-actions@github.com'

        # AWS CLI 配置
        aws configure set region auto
        aws configure set output json

        # 处理 R2 存储
        if [ ${#R2_ACCOUNT_NAME[@]} -gt 0 ]; then
          for n in "${!R2_ACCOUNT_NAME[@]}"; do
            aws configure set aws_access_key_id "${R2_ACCESS_KEY_ID[n]}"
            aws configure set aws_secret_access_key "${R2_SECRET_ACCESS_KEY[n]}"

            unset FILE_DETAIL FILE_LIST FILE_SIZE SUCCESS_UPDATE NEED_MOVE_FILE SKIP_FILE DELETE_FILE FILE_COUNTER
            FILE_DETAIL_ALL=$(aws s3api list-objects-v2 \
              --endpoint-url="${R2_ENDPOINT_URL[n]}" \
              --bucket "${R2_BUCKET[n]}")

            if grep -q '"Key"' <<< "${FILE_DETAIL_ALL}"; then
              FILE_DETAIL=$(jq '.Contents[] | {Key, Size}' <<< "${FILE_DETAIL_ALL}")
              if [ "$(jq -s 'length' <<< "${FILE_DETAIL}")" -gt 0 ]; then
                mapfile -t FILE_LIST < <(jq -r '.Key' <<< "${FILE_DETAIL}")
                mapfile -t FILE_SIZE < <(jq -r '.Size' <<< "${FILE_DETAIL}")
              fi
            fi

            if [ "${#FILE_LIST[@]}" -gt 0 ]; then
              for k in "${!FILE_LIST[@]}"; do
                if ! validate_filename "${FILE_LIST[k]#*/}"; then
                  echo "跳过无效文件名: ${FILE_LIST[k]#*/}"
                  continue
                fi
                [ "${FILE_SIZE[k]}" -le 104857600 ] && NEED_MOVE_FILE+=("${FILE_LIST[k]}") || SKIP_FILE+=("${FILE_LIST[k]}")
              done
            fi

            if [ "${#NEED_MOVE_FILE[@]}" -gt 0 ]; then
              [ ! -d "${REPO_NAME}" ] && echo "克隆节点 ${REPO_NAME}" && git clone --depth=1 "https://${GITHUB_USERNAME}:${GITHUB_PAT}@github.com/${GITHUB_USERNAME}/${REPO_NAME}.git"
              cd "${REPO_NAME}" || exit

              echo "================================="
              for l in "${NEED_MOVE_FILE[@]}"; do
                (( FILE_COUNTER++ )) || true
                echo "${R2_ACCOUNT_NAME[n]} copying ${FILE_COUNTER} / ${#NEED_MOVE_FILE[@]} : ${l#*/}"
                aws s3 cp --endpoint-url="${R2_ENDPOINT_URL[n]}" "s3://${R2_BUCKET[n]}/${l}" "${l}" >/dev/null
                DELETE_FILE+=("--include=${l}")
              done

              git add .
              git commit -m "Add images from Cloudflare R2 ${R2_ACCOUNT_NAME[n]}" || echo "No changes to commit"
              git push -f && SUCCESS_UPDATE=true || echo "No changes to push"
              cd ..

              if [ "${SUCCESS_UPDATE}" = 'true' ]; then
                if [ "${DELETE,,}" = 'true' ]; then
                  COPY_OR_MOVE='迁移'
                  echo "Delete files from CloudFlare R2 ${R2_ACCOUNT_NAME[n]}"
                  aws s3 rm --endpoint-url="${R2_ENDPOINT_URL[n]}" "s3://${R2_BUCKET[n]}" --recursive \
                    --exclude "*" "${DELETE_FILE[@]}"
                else
                  COPY_OR_MOVE='复制'
                fi

                REPORT+="\n已成功${COPY_OR_MOVE} CloudFlare R2 ${R2_ACCOUNT_NAME[n]} ${#NEED_MOVE_FILE[@]} 个文件 ---> ${REPO_NAME}"
                if [ "${#SKIP_FILE[@]}" -gt 0 ]; then
                  [ "${#SKIP_FILE[@]}" = 1 ] && \
                    REPORT+="\nWarning: ${R2_ACCOUNT_NAME[n]} 1 个文件大于 100MB，不能${COPY_OR_MOVE}到 ${REPO_NAME}，是 ${SKIP_FILE[0]#*/}" || \
                    REPORT+="\nWarning: ${R2_ACCOUNT_NAME[n]} ${#SKIP_FILE[@]} 个文件大于 100MB，不能${COPY_OR_MOVE}到 ${REPO_NAME}，分别是 ${SKIP_FILE[*]#*/}"
                fi
              else
                REPORT+="\nGitHub: ${REPO_NAME} 更新失败"
              fi
            else
              REPORT+="\nCloudFlare R2 ${R2_ACCOUNT_NAME[n]} 没有更新文件."
            fi
          done
        fi

        # B2 存储的处理部分类似，需要相应修改...
        # [B2 存储处理代码省略，需要按照相同的模式修改]

        # 本地清理
        [ -d "${REPO_NAME}" ] && rm -rf "${REPO_NAME}"

        # 打印总结报告
        echo "================================="
        echo "总结:"
        echo "${STRATEGY_RESULT}"
        echo -e "${REPORT}"

      shell: bash